# Enterprise Template - Project Rules & Guidelines

## ğŸ—ï¸ Architecture Rules

### Layer Separation
- **Client API (DMZ)**: Presentation layer for external consumers (mobile, web clients)
  - âŒ NO direct database access
  - âŒ NO EF Core DbContext usage
  - âœ… Only communicates with Server API via HTTP
  - âœ… Logs only to FILE (not database)
  - âœ… Stateless design

- **Server API (Internal)**: Business logic and data access
  - âœ… Can access database via repositories
  - âœ… Logs to FILE and DATABASE
  - âœ… Contains business rules and validations

### Project References
```
Enterprise.Api.Client (DMZ)
â”œâ”€â”€ Enterprise.Core.Shared (only)
â”œâ”€â”€ Enterprise.Infrastructure.Logging (file logging only)
â””â”€â”€ Enterprise.Infrastructure.CrossCutting
    âŒ NO reference to Enterprise.Infrastructure.Persistence
    âŒ NO reference to Enterprise.Core.Domain
    âŒ NO reference to Enterprise.Business

Enterprise.Api.Server (Internal)
â”œâ”€â”€ Enterprise.Business
â”œâ”€â”€ Enterprise.Infrastructure.Persistence
â”œâ”€â”€ Enterprise.Infrastructure.Logging
â””â”€â”€ All other internal projects
```

## ğŸ“ Logging Rules

### Central Logging Architecture
- Logs MUST be handled centrally via middleware and behaviors
- âŒ NO logging in CommandHandlers or business logic directly
- âŒ NO `_logger.LogInformation()` in business methods
- âœ… Use `AutoLoggingBehavior` for MediatR pipelines
- âœ… Use `RequestLoggingMiddleware` for HTTP requests
- âœ… Use `ExceptionLoggingMiddleware` for errors

### Log Configuration
Each log type should be independently configurable:
```json
{
  "Logging": {
    "File": {
      "Enabled": true,
      "SeparateFiles": {
        "AllLogs": true,
        "ErrorLogs": true,
        "RequestLogs": true,
        "PerformanceLogs": true,
        "BusinessLogs": true,
        "SecurityLogs": true
      }
    },
    "Database": {
      "Enabled": true,  // Server API only
      "Provider": "Oracle"
    }
  }
}
```

### Client API Logging
```json
{
  "Logging": {
    "File": { "Enabled": true },
    "Database": { "Enabled": false }  // ALWAYS false for Client API
  }
}
```

## ğŸ—„ï¸ Database Rules

### Provider Agnostic Design
- All database operations MUST work with both SqlServer and Oracle
- Use `Provider` configuration to switch databases
- âŒ NO provider-specific SQL in business code
- âœ… Provider-specific SQL only in Infrastructure layer

### Entity Configuration
- Use UPPERCASE column names for Oracle compatibility
- No schema prefix (avoid `dbo.`)
- Use `ValueGeneratedOnAdd()` for identity columns
- Use `long` for Oracle numeric IDs, `Guid` for SqlServer

### Connection String Pattern
```json
{
  "Database": {
    "Provider": "Oracle",
    "ConnectionStrings": {
      "SqlServer": "...",
      "Oracle": "..."
    }
  }
}
```

## ğŸ§¹ SOLID & Clean Code

### Single Responsibility
- One class = one purpose
- CommandHandlers only orchestrate, no business logic
- Validators only validate
- Repositories only data access

### Dependency Injection
- All dependencies via constructor injection
- Use interfaces, not concrete implementations
- Register services in `Register*Configuration.cs` files

### Code Organization
```
Feature/
â”œâ”€â”€ Commands/
â”‚   â”œâ”€â”€ CreateCustomer/
â”‚   â”‚   â”œâ”€â”€ CreateCustomerCommand.cs
â”‚   â”‚   â”œâ”€â”€ CreateCustomerCommandHandler.cs
â”‚   â”‚   â””â”€â”€ CreateCustomerCommandValidator.cs
â”‚   â””â”€â”€ UpdateCustomer/
â””â”€â”€ Queries/
    â””â”€â”€ GetCustomerById/
```

### Naming Conventions
- Commands: `{Action}{Entity}Command`
- Queries: `Get{Entity}By{Criteria}Query`
- Handlers: `{Command/Query}Handler`
- Validators: `{Command}Validator`

## ğŸ“š Documentation Rules

### Required Updates
After ANY code change, update relevant documentation:
- `docs/01-PROJECT-PROMPTS.md` - Architecture decisions
- `docs/02-LOGGING-ARCHITECTURE-REPORT.md` - Logging changes
- `docs/03-HIGH-LEVEL-DESIGN.md` - Design changes
- `docs/scripts/oracle-ddl.sql` - Database schema changes

### Documentation Checklist
- [ ] New features documented
- [ ] API changes reflected
- [ ] Configuration examples updated
- [ ] Breaking changes noted

## âš ï¸ Error Handling

### Exception Strategy
- Use custom exceptions: `BusinessException`, `NotFoundException`, `ValidationException`
- Handle exceptions in `ExceptionHandlingBehavior` (MediatR)
- Handle HTTP exceptions in `ExceptionLoggingMiddleware`
- âŒ NO try-catch in business logic (unless re-throwing)

### Error Response Format
```json
{
  "success": false,
  "errorCode": "CUSTOMER_NOT_FOUND",
  "message": "User friendly message",
  "correlationId": "xxx-xxx"
}
```

## ğŸ”’ Security Rules

### Sensitive Data
- Use `SensitiveDataMasker` for logging
- Never log passwords, tokens, credit cards
- Mask PII in logs automatically

### API Security
- JWT authentication for Server API
- API Key authentication for Client API (optional)
- CORS properly configured

## ğŸ§ª Testing Rules

### âš¡ AUTO-GENERATE UNIT TESTS
**Her yeni API metodu veya Handler yazÄ±ldÄ±ÄŸÄ±nda otomatik olarak unit test oluÅŸtur!**

Hedef: **Minimum %80 code coverage**

### Test Generation Checklist
Yeni bir metot yazÄ±ldÄ±ÄŸÄ±nda ÅŸu testleri OTOMATIK oluÅŸtur:

#### 1. CommandHandler Tests
```csharp
// Her CommandHandler iÃ§in ÅŸu senaryolarÄ± test et:
âœ… Handle_ShouldReturnSuccess_WhenValidRequest
âœ… Handle_ShouldReturnFailure_WhenEntityNotFound
âœ… Handle_ShouldReturnFailure_WhenDuplicateExists
âœ… Handle_ShouldThrowValidationException_WhenInvalidInput
âœ… Handle_ShouldCallRepository_WithCorrectParameters
âœ… Handle_ShouldCallUnitOfWork_SaveChanges
âœ… Handle_ShouldReturnCorrectResponse_WhenSuccess
```

#### 2. QueryHandler Tests
```csharp
// Her QueryHandler iÃ§in ÅŸu senaryolarÄ± test et:
âœ… Handle_ShouldReturnData_WhenEntityExists
âœ… Handle_ShouldThrowNotFoundException_WhenEntityNotFound
âœ… Handle_ShouldReturnCorrectDto_WithAllFieldsMapped
âœ… Handle_ShouldCallRepository_WithCorrectId
```

#### 3. Validator Tests
```csharp
// Her Validator iÃ§in ÅŸu senaryolarÄ± test et:
âœ… Validate_ShouldPass_WhenAllFieldsValid
âœ… Validate_ShouldFail_WhenRequiredFieldEmpty (her alan iÃ§in)
âœ… Validate_ShouldFail_WhenFieldExceedsMaxLength (her alan iÃ§in)
âœ… Validate_ShouldFail_WhenInvalidFormat (email, phone vb.)
âœ… Validate_ShouldReturnCorrectErrorMessage
```

#### 4. Controller/API Tests
```csharp
// Her API endpoint iÃ§in ÅŸu senaryolarÄ± test et:
âœ… Endpoint_ShouldReturn200_WhenSuccess
âœ… Endpoint_ShouldReturn201_WhenCreated
âœ… Endpoint_ShouldReturn400_WhenBadRequest
âœ… Endpoint_ShouldReturn404_WhenNotFound
âœ… Endpoint_ShouldReturn422_WhenValidationFails
âœ… Endpoint_ShouldReturn500_WhenUnhandledException
```

#### 5. Repository Tests (Integration)
```csharp
// Her Repository metodu iÃ§in:
âœ… Method_ShouldReturnEntity_WhenExists
âœ… Method_ShouldReturnNull_WhenNotExists
âœ… Method_ShouldPersistEntity_WhenAdded
âœ… Method_ShouldUpdateEntity_WhenModified
âœ… Method_ShouldSoftDelete_WhenDeleted
```

### Test File Structure
```
tests/
â”œâ”€â”€ Enterprise.UnitTests/
â”‚   â”œâ”€â”€ Business/
â”‚   â”‚   â””â”€â”€ Customers/
â”‚   â”‚       â”œâ”€â”€ CreateCustomerCommandHandlerTests.cs
â”‚   â”‚       â”œâ”€â”€ CreateCustomerCommandValidatorTests.cs
â”‚   â”‚       â”œâ”€â”€ GetCustomerByIdQueryHandlerTests.cs
â”‚   â”‚       â””â”€â”€ UpdateCustomerCommandHandlerTests.cs
â”‚   â””â”€â”€ Infrastructure/
â”‚       â””â”€â”€ Repositories/
â”‚           â””â”€â”€ CustomerRepositoryTests.cs
â”œâ”€â”€ Enterprise.IntegrationTests/
â”‚   â””â”€â”€ Api/
â”‚       â””â”€â”€ CustomersControllerTests.cs
â””â”€â”€ Enterprise.ArchitectureTests/
    â””â”€â”€ LayerDependencyTests.cs
```

### Test Template - CommandHandler
```csharp
public class Create{Entity}CommandHandlerTests
{
    private readonly Mock<IRepository<{Entity}, long>> _repositoryMock;
    private readonly Mock<IUnitOfWork> _unitOfWorkMock;
    private readonly Create{Entity}CommandHandler _handler;
    private readonly Fixture _fixture;

    public Create{Entity}CommandHandlerTests()
    {
        _fixture = new Fixture();
        _repositoryMock = new Mock<IRepository<{Entity}, long>>();
        _unitOfWorkMock = new Mock<IUnitOfWork>();
        _handler = new Create{Entity}CommandHandler(
            _repositoryMock.Object,
            _unitOfWorkMock.Object,
            /* other dependencies */);
    }

    [Fact]
    public async Task Handle_ShouldReturnSuccess_WhenValidRequest()
    {
        // Arrange
        var command = _fixture.Create<Create{Entity}Command>();
        _repositoryMock.Setup(x => x.ExistsAsync(It.IsAny<Expression<Func<{Entity}, bool>>>(), default))
            .ReturnsAsync(false);

        // Act
        var result = await _handler.Handle(command, CancellationToken.None);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _repositoryMock.Verify(x => x.AddAsync(It.IsAny<{Entity}>(), default), Times.Once);
        _unitOfWorkMock.Verify(x => x.SaveChangesAsync(default), Times.Once);
    }

    [Fact]
    public async Task Handle_ShouldThrowBusinessException_WhenDuplicateExists()
    {
        // Arrange
        var command = _fixture.Create<Create{Entity}Command>();
        _repositoryMock.Setup(x => x.ExistsAsync(It.IsAny<Expression<Func<{Entity}, bool>>>(), default))
            .ReturnsAsync(true);

        // Act & Assert
        await Assert.ThrowsAsync<BusinessException>(
            () => _handler.Handle(command, CancellationToken.None));
    }
}
```

### Test Template - Validator
```csharp
public class Create{Entity}CommandValidatorTests
{
    private readonly Create{Entity}CommandValidator _validator;

    public Create{Entity}CommandValidatorTests()
    {
        _validator = new Create{Entity}CommandValidator();
    }

    [Fact]
    public void Validate_ShouldPass_WhenAllFieldsValid()
    {
        // Arrange
        var command = new Create{Entity}Command(
            "ValidFirstName",
            "ValidLastName",
            "valid@email.com",
            "5551234567");

        // Act
        var result = _validator.Validate(command);

        // Assert
        result.IsValid.Should().BeTrue();
    }

    [Theory]
    [InlineData("")]
    [InlineData(null)]
    [InlineData("   ")]
    public void Validate_ShouldFail_WhenFirstNameEmpty(string firstName)
    {
        // Arrange
        var command = new Create{Entity}Command(firstName, "Last", "email@test.com", null);

        // Act
        var result = _validator.Validate(command);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(e => e.PropertyName == "FirstName");
    }

    [Fact]
    public void Validate_ShouldFail_WhenEmailInvalidFormat()
    {
        // Arrange
        var command = new Create{Entity}Command("First", "Last", "invalid-email", null);

        // Act
        var result = _validator.Validate(command);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(e => e.PropertyName == "Email");
    }
}
```

### Coverage Requirements
| Component | Minimum Coverage |
|-----------|-----------------|
| CommandHandlers | 90% |
| QueryHandlers | 90% |
| Validators | 100% |
| Controllers | 80% |
| Repositories | 80% |
| Services | 85% |
| **Overall** | **80%** |

### Test Libraries
```xml
<PackageReference Include="xunit" />
<PackageReference Include="xunit.runner.visualstudio" />
<PackageReference Include="Moq" />
<PackageReference Include="AutoFixture" />
<PackageReference Include="AutoFixture.Xunit2" />
<PackageReference Include="AutoFixture.AutoMoq" />
<PackageReference Include="FluentAssertions" />
<PackageReference Include="Bogus" />
<PackageReference Include="Microsoft.NET.Test.Sdk" />
<PackageReference Include="coverlet.collector" />
```

### Test Naming Convention
```
{MethodName}_Should{ExpectedBehavior}_When{Condition}
```
Examples:
- `Handle_ShouldReturnSuccess_WhenValidRequest`
- `Validate_ShouldFail_WhenEmailEmpty`
- `GetById_ShouldReturn404_WhenCustomerNotFound`

### Running Tests with Coverage
```bash
# Run tests with coverage
dotnet test --collect:"XPlat Code Coverage"

# Generate HTML report
reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport
```

## ğŸ“‹ Configuration Rules

### appsettings Structure
```
appsettings.json           - Base configuration
appsettings.Development.json - Dev overrides
appsettings.Production.json  - Prod overrides
```

### Environment-Specific Settings
- Connection strings via environment variables in production
- Sensitive data never in source control
- Use User Secrets for local development

## ğŸ”„ Change Checklist

When making changes:
1. [ ] Follow layer separation rules
2. [ ] Update documentation in `docs/` folder
3. [ ] **AUTO-GENERATE unit tests** (min %80 coverage)
4. [ ] Check Oracle compatibility
5. [ ] Verify logging configuration
6. [ ] Run linter checks
7. [ ] Update DDL scripts if schema changed
8. [ ] Run all tests and verify coverage

### API Method Ekleme Checklist
Yeni bir API metodu eklendiÄŸinde:
1. [ ] Controller action oluÅŸtur
2. [ ] Command/Query oluÅŸtur
3. [ ] Handler oluÅŸtur
4. [ ] Validator oluÅŸtur
5. [ ] **Unit Tests OTOMATIK OLUÅTUR:**
   - [ ] HandlerTests (success, failure, validation scenarios)
   - [ ] ValidatorTests (all field validations)
   - [ ] ControllerTests (all HTTP status codes)
6. [ ] Integration tests ekle
7. [ ] Swagger dokÃ¼mantasyonu gÃ¼ncelle
8. [ ] docs/ klasÃ¶rÃ¼nÃ¼ gÃ¼ncelle
